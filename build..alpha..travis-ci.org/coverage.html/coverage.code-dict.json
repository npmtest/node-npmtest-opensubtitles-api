{"/home/travis/build/npmtest/node-npmtest-opensubtitles-api/test.js":"/* istanbul instrument in package npmtest_opensubtitles_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-opensubtitles-api/lib.npmtest_opensubtitles_api.js":"/* istanbul instrument in package npmtest_opensubtitles_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_opensubtitles_api = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_opensubtitles_api = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-opensubtitles-api/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-opensubtitles-api && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_opensubtitles_api */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_opensubtitles_api\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_opensubtitles_api.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_opensubtitles_api.rollup.js'] =\n            local.assetsDict['/assets.npmtest_opensubtitles_api.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_opensubtitles_api.__dirname + '/lib.npmtest_opensubtitles_api.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-opensubtitles-api/node_modules/opensubtitles-api/index.js":"const OS = require('./lib/opensubtitles.js')\r\nconst libhash = require('./lib/hash.js')\r\nconst libsearch = require('./lib/search.js')\r\nconst libupload = require('./lib/upload.js')\r\nconst libid = require('./lib/identify.js')\r\n\r\nmodule.exports = class OpenSubtitles {\r\n\r\n    /**\r\n     * Construct the module's skeleton\r\n     * @param {Object}|{String} creds - the required information to use OpenSubtitles, can be simply the UA\r\n     *\r\n     * @param {String}          creds.useragent - mandatory, the OpenSubtitles User Agent\r\n     * @param {String}          creds.endpoint - optionnal, the endpoint to use.\r\n     * @param {Boolean}         creds.ssl - optionnal, set to true to use https.\r\n     * @param {String}          creds.username - optionnal, the username of a specific user\r\n     * @param {String}          creds.password - optionnal, the password of a specific user (can be MD5)\r\n     */\r\n    constructor(creds) {\r\n        if (!creds || (typeof creds === 'object' && !creds.useragent)) throw Error('Missing useragent')\r\n\r\n        this.credentials = {\r\n            username: creds.username || String(),\r\n            password: creds.password || String(),\r\n            useragent: creds.useragent || creds,\r\n            status: Object(),\r\n            userinfo: Object()\r\n        }\r\n\r\n        this.api = new OS(creds.endpoint, creds.ssl)\r\n    }\r\n\r\n\r\n    /**\r\n     * Log-in as user or anonymously, returns a token\r\n     */\r\n    login() {\r\n        if (this.credentials.status.auth_as === this.credentials.username && this.credentials.status.ttl > Date.now()) {\r\n            return Promise.resolve({\r\n                token: this.credentials.status.token,\r\n                userinfo: this.credentials.userinfo\r\n            })\r\n        }\r\n\r\n        return this.api.LogIn(this.credentials.username, this.credentials.password, 'en', this.credentials.useragent).then(response => {\r\n            if (response.token && (response.status && response.status.match(/200/))) {\r\n                this.credentials.status.ttl = Date.now() + 895000 // ~15 min\r\n                this.credentials.status.token = response.token\r\n                this.credentials.status.auth_as = this.credentials.username\r\n                this.credentials.userinfo = response.data\r\n                return {\r\n                    token: response.token,\r\n                    userinfo: response.data\r\n                }\r\n            }\r\n\r\n            this.credentials.status = this.credentials.userinfo = Object()\r\n            throw Error(response.status || 'LogIn unknown error')\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Search for subtitles\r\n     * @param {Object}          info - information about the video to be subtitled\r\n     *\r\n     * @param {String}|{Array}  info.extensions - Accepted extensions, defaults to 'srt' (values: srt, sub, smi, txt, ssa, ass, mpl)\r\n     * @param {String}|{Array}  info.sublanguageid - Desired subtitle lang, ISO639-3 langcode, defaults to 'all'\r\n     * @param {String}          info.hash - Size + 64bit checksum of the first and last 64k\r\n     * @param {String}          info.path - Absolute path to the video file, it allows to automatically calculate 'hash'\r\n     * @param {String}|{Int}    info.filesize - Total size, in bytes\r\n     * @param {String}          info.filename - The video file name. Better if extension is included\r\n     * @param {String}|{Int}    info.season - If TV Episode\r\n     * @param {String}|{Int}    info.episode - If TV Episode\r\n     * @param {String}|{Int}    info.imdbid - IMDB id with or without leading 'tt'\r\n     * @param {String}|{Int}    info.fps - Number of frames per sec in the video\r\n     * @param {String}          info.query - Text-based query, this is not recommended\r\n     * @param {String}|{Int}    info.limit - Number of subtitles to return for each language, can be 'best', 'all' or an arbitrary number. Defaults to 'best'\r\n     */\r\n    search(info) {\r\n        let subs = Array()\r\n\r\n        return this.login()\r\n            .then(() => libsearch.optimizeQueryTerms(info))\r\n            .then(optimizedQT => {\r\n                return Promise.all(optimizedQT.map(op => {\r\n                    return this.api.SearchSubtitles(this.credentials.status.token, [op]).then(result => subs = subs.concat(result.data))\r\n                }))\r\n            })\r\n            .then(() => libsearch.optimizeSubs(subs, info))\r\n            .then(list => libsearch.filter(list, info))\r\n    }\r\n\r\n    /**\r\n     * Upload a subtitle\r\n     * @param {Object}          subtitle - information about the video to be subtitled\r\n     *\r\n     * @param {String}          subtitle.path - Mandatory, absolute path to the video file\r\n     * @param {String}          subtitle.subpath - Mandatory, absolute path to the subtitle file\r\n     * @param {String}|{Int}    subtitle.imdbid - Recommended, IMDB id with or without leading 'tt'\r\n     * @param {String}          subtitle.sublanguageid - Optionnal, subtitle lang, ISO639-3 langcode (autodetected upstream)\r\n     * @param {String}          subtitle.moviereleasename - Optionnal, the release tag/name\r\n     * @param {String}          subtitle.movieaka - Optionnal, alternative title\r\n     * @param {String}|{Int}    subtitle.moviefps - Optionnal, number of frames per sec\r\n     * @param {String}|{Int}    subtitle.movieframes - Optionnal, total number of frames\r\n     * @param {String}|{Int}    subtitle.movietimems - Optionnal, total time in milliseconds\r\n     * @param {String}|{Boolean}subtitle.highdefinition - Optionnal, is the video more than 720p? '1' or '0', true or false\r\n     * @param {String}|{Boolean}subtitle.hearingimpaired - Optionnal, does the subtitle have descriptions for every sound? '1' or '0', true or false\r\n     * @param {String}|{Boolean}subtitle.automatictranslation - Optionnal, is the subtitle machine-translated? '1' or '0', true or false\r\n     * @param {String}          subtitle.subauthorcomment - Optionnal, commentary for the uploaded subtitle\r\n     * @param {String}          subtitle.subtranslator - Optionnal, person who translated the subtitles\r\n     */\r\n    upload(subtitle) {\r\n        return new Promise((resolve, reject) => {\r\n            let persistent_data = Object()\r\n\r\n            this.login()\r\n                .then(() => libupload.createTryData(subtitle))\r\n                .then(tryArray => {\r\n                    persistent_data = tryArray.cd1\r\n                    return this.api.TryUploadSubtitles(this.credentials.status.token, tryArray)\r\n                })\r\n                .then(response => {\r\n                    if (response.alreadyindb === 1) {\r\n                        resolve(response) // it exists, don't go further\r\n                    } else {\r\n                        persistent_data.subpath = subtitle.subpath // inject subpath\r\n                        return libupload.parseResponse(response, persistent_data)\r\n                    }\r\n                })\r\n                .then(libupload.createContent)\r\n                .then(libupload.arrangeUploadData)\r\n                .then(uploadArray => this.api.UploadSubtitles(this.credentials.status.token, uploadArray))\r\n                .then(response => {\r\n                    if (response.data === String() || !response.status.match(/200/)) throw Error(response.status || 'UploadSubtitles unknown error')\r\n                    resolve(response)\r\n                }).catch(reject)\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Extract Movie Hash & Movie Bytes Size from a video\r\n     * @param {String}          path - Mandatory, absolute path to a video file\r\n     */\r\n    hash(path) {\r\n        if (!path) throw Error('Missing path')\r\n        return libhash.computeHash(path)\r\n    }\r\n\r\n    /**\r\n     * Movie identification service, get imdb information, send moviehashes\r\n     * @param {Object}          \r\n     * \r\n     * @param {String}          path - Mandatory, absolute path to a video file\r\n     * @param {String}          imdb - Optionnal, matching imdb id\r\n     * @param {Boolean}         extend - Optionnal, fetches metadata from OpenSubtitles\r\n     */\r\n    identify(query) {\r\n        if (!query && !query.path) throw Error('Missing path')\r\n        if (!query.path) query = {path: query}\r\n\r\n        return this.login()\r\n            .then(() => this.extractInfo(query.path))\r\n            .then(info => {\r\n                query.moviehash = info.moviehash\r\n                query.moviebytesize = info.moviebytesize\r\n                return this.api.CheckMovieHash(this.credentials.status.token, [query.moviehash])\r\n            })\r\n            .then(response => {\r\n                if (response.data === String() || !response.status.match(/200/)) throw Error(response.status || 'OpenSubtitles unknown error')\r\n\r\n                const id = query.imdb || libid.readNFO(query.path)\r\n                if (response.data[query.moviehash].length === 0 && id) {\r\n                    return this.api.InsertMovieHash(this.credentials.status.token, [{\r\n                        moviehash: query.moviehash,\r\n                        moviebytesize: query.moviebytesize,\r\n                        imdbid: id.replace('tt', ''),\r\n                        moviefilename: require('path').basename(query.path)\r\n                    }])\r\n                } else {\r\n                    return response\r\n                }\r\n            })\r\n            .then(response => libid.parseResponse(response, query))\r\n            .then(data => {\r\n                if (data.metadata && data.metadata.imdbid && query.extend) {\r\n                    return this.api.GetIMDBMovieDetails(this.credentials.status.token, data.metadata.imdbid.replace('tt', '')).then(ext => libid.extend(data, ext))\r\n                } else {\r\n                    return data\r\n                }\r\n            })\r\n    }\r\n\r\n    /**\r\n     * Extract md5 hash from a subtitle file\r\n     * @param {String}          path - Mandatory, absolute path to a subtitle file\r\n     */\r\n    md5(path) {\r\n        if (!path) throw Error('Missing path')\r\n        return libhash.computeMD5(path)\r\n    }\r\n}","/home/travis/build/npmtest/node-npmtest-opensubtitles-api/node_modules/opensubtitles-api/lib/opensubtitles.js":"const xmlrpc = require('xmlrpc')\r\nconst URIjs = require('urijs')\r\n\r\nconst pjson = require('../package.json')\r\nconst url = 'http://api.opensubtitles.org:80/xml-rpc'\r\nconst url_ssl = 'https://api.opensubtitles.org:443/xml-rpc'\r\n\r\nmodule.exports = class OS {\r\n    constructor(endpoint, ssl) {\r\n        const UA = pjson.name + ' v' + pjson.version\r\n        const uri = endpoint || (ssl ? url_ssl : url)\r\n        const req = URIjs(uri)._parts\r\n        const secure = req.protocol === 'https'\r\n\r\n        const opts = {\r\n            host: req.hostname,\r\n            port: req.port || (secure ? 443 : 80),\r\n            path: req.path,\r\n            headers: {\r\n                'User-Agent': UA\r\n            }\r\n        }\r\n\r\n        this.client = secure ? xmlrpc.createSecureClient(opts) : xmlrpc.createClient(opts)\r\n    }\r\n\r\n    handleError(error) {\r\n        error.message && error.message.match('XML-RPC tag \\'TITLE\\'') && (error.message = 'API seems offline')\r\n        return error\r\n    }\r\n\r\n    call(method, args) {\r\n        return new Promise((resolve, reject) => {\r\n            this.client.methodCall(method, [...args], (err, data) => {\r\n                if (err) return reject(this.handleError(err))\r\n                resolve(data)\r\n            })\r\n        })\r\n    }\r\n\r\n    LogIn(username, password, language, useragent) {\r\n        return this.call('LogIn', arguments)\r\n    }\r\n    LogOut(token) {\r\n        return this.call('LogOut', arguments)\r\n    }\r\n    SearchSubtitles(token, array_queries) {\r\n        return this.call('SearchSubtitles', arguments)\r\n    }\r\n    SearchToMail(token, array_langs, array_movies) {\r\n        return this.call('SearchToMail', arguments)\r\n    }\r\n    CheckSubHash(token, array_subs_hash) {\r\n        return this.call('CheckSubHash', arguments)\r\n    }\r\n    CheckMovieHash(token, array_movies_hash) {\r\n        return this.call('CheckMovieHash', arguments)\r\n    }\r\n    CheckMovieHash2(token, array_movies_hash) {\r\n        return this.call('CheckMovieHash2', arguments)\r\n    }\r\n    InsertMovieHash(token, array_movies_info) {\r\n        return this.call('InsertMovieHash', arguments)\r\n    }\r\n    TryUploadSubtitles(token, array_sub) {\r\n        return this.call('TryUploadSubtitles', arguments)\r\n    }\r\n    UploadSubtitles(token, array_sub) {\r\n        return this.call('UploadSubtitles', arguments)\r\n    }\r\n    DetectLanguage(token, array_texts) {\r\n        return this.call('DetectLanguage', arguments)\r\n    }\r\n    DownloadSubtitles(token, array_subid) {\r\n        return this.call('DownloadSubtitles', arguments)\r\n    }\r\n    ReportWrongMovieHash(token, IDSubMovieFile) {\r\n        return this.call('ReportWrongMovieHash', arguments)\r\n    }\r\n    ReportWrongImdbMovie(token, array_movie) {\r\n        return this.call('ReportWrongImdbMovie', arguments)\r\n    }\r\n    GetSubLanguages(language) {\r\n        return this.call('GetSubLanguages', arguments)\r\n    }\r\n    GetAvailableTranslations(token, program) {\r\n        return this.call('GetAvailableTranslations', arguments)\r\n    }\r\n    GetTranslation(token, iso639, format, program) {\r\n        return this.call('GetTranslation', arguments)\r\n    }\r\n    GetUserInfo(token) {\r\n        return this.call('GetUserInfo', arguments)\r\n    }\r\n    SearchMoviesOnIMDB(token, query) {\r\n        return this.call('SearchMoviesOnIMDB', arguments)\r\n    }\r\n    GuessMovieFromString(token, array_titles) {\r\n        // Beta - might break or stop working\r\n        return this.call('GuessMovieFromString', arguments)\r\n    }\r\n    GetIMDBMovieDetails(token, imdbid) {\r\n        return this.call('GetIMDBMovieDetails', arguments)\r\n    }\r\n    InsertMovie(token, array_movie) {\r\n        return this.call('InsertMovie', arguments)\r\n    }\r\n    SubtitlesVote(token, array_vote) {\r\n        return this.call('SubtitlesVote', arguments)\r\n    }\r\n    GetComments(token, array_subids) {\r\n        return this.call('GetComments', arguments)\r\n    }\r\n    AddComment(token, array_comments) {\r\n        return this.call('AddComment', arguments)\r\n    }\r\n    AddRequest(token, array_request) {\r\n        return this.call('AddRequest', arguments)\r\n    }\r\n    SetSubscribeUrl(token, url) {\r\n        return this.call('SetSubscribeUrl', arguments)\r\n    }\r\n    SubscribeToHash(token, array_hashs) {\r\n        return this.call('SubscribeToHash', arguments)\r\n    }\r\n    AutoUpdate(program_name) {\r\n        return this.call('AutoUpdate', arguments)\r\n    }\r\n    SuggestMovie(token, querystring) {\r\n        return this.call('SuggestMovie', arguments)\r\n    }\r\n    QuickSuggest(token, str, sublanguageid) {\r\n        return this.call('QuickSuggest', arguments)\r\n    }\r\n    NoOperation(token) {\r\n        return this.call('NoOperation', arguments)\r\n    }\r\n    ServerInfo() {\r\n        return this.call('ServerInfo', [])\r\n    }\r\n}","/home/travis/build/npmtest/node-npmtest-opensubtitles-api/node_modules/opensubtitles-api/lib/hash.js":"const fs = require('fs')\r\nconst crypto = require('crypto')\r\nconst zlib = require('zlib')\r\n\r\nmodule.exports = new class LibHash {\r\n\r\n    // opens the file, gzip the content and base64 encode it\r\n    computeSubContent(path) {\r\n        return new Promise((resolve, reject) => {\r\n            fs.readFile(path, (err, data) => {\r\n                if (err) return reject(err)\r\n                zlib.deflate(data, (err, buffer) => {\r\n                    if (err) return reject(err)\r\n                    resolve(buffer.toString('base64'))\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n    // get md5 of a file\r\n    computeMD5(path) {\r\n        return new Promise((resolve, reject) => {\r\n            let hash = crypto.createHash('md5')\r\n\r\n            fs.createReadStream(path)\r\n                .on('data', data => hash.update(data, 'utf8'))\r\n                .on('end', () => resolve(hash.digest('hex'))) // md5 checksum\r\n                .on('error', reject)\r\n        })\r\n    }\r\n\r\n    computeHash(path) {\r\n        // based on node-opensubtitles-api, under MIT - Copyright (c) 2015 ka2er\r\n\r\n        return new Promise((resolve, reject) => {\r\n            // get file size, first 64kb, last 64kb and summup everything\r\n            let chunk_size = 65536 //64 * 1024\r\n            let buf_start = new Buffer(chunk_size * 2)\r\n            let buf_end = new Buffer(chunk_size * 2)\r\n            let file_size = 0\r\n            let checksum\r\n            let array_checksum = Array()\r\n\r\n            const checksumReady = checksum_part => {\r\n                array_checksum.push(checksum_part)\r\n                if (array_checksum.length === 3) {\r\n                    checksum = this.sumHex64bits(array_checksum[0], array_checksum[1])\r\n                    checksum = this.sumHex64bits(checksum, array_checksum[2])\r\n                    checksum = checksum.substr(-16)\r\n\r\n                    resolve({\r\n                        moviehash: this.padLeft(checksum, '0', 16),\r\n                        moviebytesize: file_size.toString()\r\n                    })\r\n                }\r\n            }\r\n\r\n            fs.stat(path, (err, stat) => {\r\n                if (err) return reject(err)\r\n\r\n                file_size = stat.size\r\n\r\n                checksumReady(file_size.toString(16))\r\n\r\n                fs.open(path, 'r', (err, fd) => {\r\n                    if (err) return reject(err)\r\n\r\n                    fs.read(fd, buf_start, 0, chunk_size * 2, 0, (er1, bytesRead, buf1) => {\r\n                        fs.read(fd, buf_end, 0, chunk_size * 2, file_size - chunk_size, (er2, bytesRead, buf2) => {\r\n                            fs.close(fd, er3 => {\r\n                                if (er1 || er2) return reject(er1 || er2) //er3 is not breaking\r\n                                checksumReady(this.checksumBuffer(buf1, 16))\r\n                                checksumReady(this.checksumBuffer(buf2, 16))\r\n                            })\r\n                        })\r\n                    })\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n    // read 64 bits from buffer starting at offset as LITTLE ENDIAN hex\r\n    read64LE(buffer, offset) {\r\n        const ret_64_be = buffer.toString('hex', offset * 8, ((offset + 1) * 8))\r\n        const array = Array()\r\n        for (let i = 0; i < 8; i++) {\r\n            array.push(ret_64_be.substr(i * 2, 2))\r\n        }\r\n        array.reverse()\r\n        return array.join('')\r\n    }\r\n\r\n    // compute checksum of the buffer splitting by chunk of lengths bits\r\n    checksumBuffer(buf, length) {\r\n        let checksum = 0\r\n        let checksum_hex = 0\r\n        for (let i = 0; i < (buf.length / length); i++) {\r\n            checksum_hex = this.read64LE(buf, i)\r\n            checksum = this.sumHex64bits(checksum.toString(), checksum_hex).substr(-16)\r\n        }\r\n        return checksum\r\n    }\r\n\r\n    // calculate hex sum between 2 64bits hex numbers\r\n    sumHex64bits(n1, n2) {\r\n        if (n1.length < 16) n1 = this.padLeft(n1, '0', 16)\r\n        if (n2.length < 16) n2 = this.padLeft(n2, '0', 16)\r\n\r\n        // 1st 32 bits\r\n        let n1_0 = n1.substr(0, 8)\r\n        let n2_0 = n2.substr(0, 8)\r\n        let i_0 = parseInt(n1_0, 16) + parseInt(n2_0, 16)\r\n\r\n        // 2nd 32 bits\r\n        let n1_1 = n1.substr(8, 8)\r\n        let n2_1 = n2.substr(8, 8)\r\n        let i_1 = parseInt(n1_1, 16) + parseInt(n2_1, 16)\r\n\r\n        // back to hex\r\n        let h_1 = i_1.toString(16)\r\n        let i_1_over = 0\r\n        if (h_1.length > 8) {\r\n            i_1_over = parseInt(h_1.substr(0, h_1.length - 8), 16)\r\n        } else {\r\n            h_1 = this.padLeft(h_1, '0', 8)\r\n        }\r\n\r\n        let h_0 = (i_1_over + i_0).toString(16)\r\n\r\n        return h_0 + h_1.substr(-8)\r\n    }\r\n\r\n    // pad left with c up to length characters\r\n    padLeft(str, c, length) {\r\n        while (str.length < length) {\r\n            str = c.toString() + str\r\n        }\r\n        return str\r\n    }\r\n}","/home/travis/build/npmtest/node-npmtest-opensubtitles-api/node_modules/opensubtitles-api/lib/search.js":"const OS = require('./opensubtitles.js')\r\nconst libhash = require('./hash.js')\r\nconst path = require('path')\r\n\r\nmodule.exports = new class LibSearch {\r\n\r\n    checkHash(input) {\r\n        return new Promise((resolve, reject) => {\r\n            if (!input.hash && !input.path) return resolve(false)\r\n\r\n            if (!input.hash && input.path) return libhash.computeHash(input.path).then(resolve).catch(reject)\r\n\r\n            const tmpObj = { moviehash: input.hash }\r\n            if (input.filesize) tmpObj.moviebytesize = input.filesize.toString()\r\n            resolve(tmpObj)\r\n        })\r\n    }\r\n\r\n    optimizeQueryTerms(input) {\r\n        return this.checkHash(input).then(obj => {\r\n            const output = Array()\r\n            let i = 0\r\n\r\n            if (obj) { // first data call\r\n                output[i] = obj\r\n                i++\r\n            }\r\n\r\n            if (input.filename || input.path) { // second data call\r\n                output[i] = Object()\r\n                output[i].tag = input.filename || path.basename(input.path)\r\n                i++\r\n            }\r\n\r\n            if (input.imdbid) { // third data call\r\n                output[i] = Object()\r\n                output[i].imdbid = input.imdbid.toString().replace('tt', '')\r\n\r\n                if (input.season && input.episode) {\r\n                    output[i].season = parseInt(input.season).toString()\r\n                    output[i].episode = parseInt(input.episode).toString()\r\n                }\r\n                i++\r\n            }\r\n\r\n            if (!input.imdbid && !input.hash && !input.path && !input.filename && input.query) { // fallback\r\n                output[i] = Object()\r\n                output[i].query = input.query\r\n\r\n                if (input.season && input.episode) {\r\n                    output[i].season = parseInt(input.season).toString()\r\n                    output[i].episode = parseInt(input.episode).toString()\r\n                }\r\n                i++\r\n            }\r\n\r\n            // mandatory lang parameter\r\n            for (let o of output) {\r\n                o.sublanguageid = input.sublanguageid || 'all'\r\n            }\r\n\r\n            return output\r\n        })\r\n    }\r\n\r\n    normalizeProt() {\r\n        const from = 'ÃÀÁÄÂÈÉËÊÌÍÏÎÒÓÖÔÙÚÜÛãàáäâèéëêìíïîòóöôùúüûÑñÇç'\r\n        const to = 'AAAAAEEEEIIIIOOOOUUUUaaaaaeeeeiiiioooouuuunncc'\r\n        const mapping = Object()\r\n\r\n        for (let i = 0, j = from.length; i < j; i++) {\r\n            mapping[from.charAt(i)] = to.charAt(i)\r\n        }\r\n\r\n        return str => {\r\n            const ret = Array()\r\n            for (let i = 0, j = str.length; i < j; i++) {\r\n                let c = str.charAt(i)\r\n                ret.push(mapping[c] || c)\r\n            }\r\n            return ret.join('')\r\n        }\r\n    }\r\n\r\n    optimizeSubs(response, input) {\r\n        // based on OpenSRTJS, under MIT - Copyright (c) 2014 Eóin Martin\r\n\r\n        let fileTags\r\n        let fileTagsDic = Object()\r\n        const normalize = this.normalizeProt()\r\n        const matchTags = (sub, maxScore) => {\r\n            if (!input.filename) return 0\r\n\r\n            if (!fileTags) fileTags = normalize(input.filename).toLowerCase().match(/[a-z0-9]{2,}/gi)\r\n            if (!fileTags.length) return 0\r\n\r\n            const subNames = normalize(sub.MovieReleaseName + '_' + sub.SubFileName)\r\n            const subTags = subNames.toLowerCase().match(/[a-z0-9]{2,}/gi)\r\n\r\n            if (!subTags.length) return 0\r\n\r\n            for (let tag of fileTags) fileTagsDic[tag] = false\r\n\r\n            let matches = 0\r\n            for (let subTag of subTags) { // is term in filename, only once\r\n                if (!fileTagsDic[subTag]) {\r\n                    fileTagsDic[subTag] = true\r\n                    matches++\r\n                }\r\n            }\r\n\r\n            return parseInt((matches / fileTags.length) * maxScore)\r\n        }\r\n\r\n        const subtitles = Object()\r\n\r\n        // if string passed as supported extension, convert to array\r\n        if (input.extensions && typeof input.extensions === 'string') input.extensions = [input.extensions]\r\n\r\n        // if no supported extensions passed, default to 'srt'\r\n        if (!input.extensions || !input.extensions instanceof Array) input.extensions = ['srt']\r\n\r\n        return Promise.all(response.map(sub => {\r\n            if (!sub || input.extensions.indexOf(sub.SubFormat) == -1) return\r\n\r\n            // imdbid check\r\n            if (input.imdbid) {\r\n                let tmpId = parseInt(input.imdbid.toString().replace('tt', ''), 10)\r\n\r\n                if (sub.SeriesIMDBParent && sub.SeriesIMDBParent.toString() !== '0') {\r\n                    if (parseInt(sub.SeriesIMDBParent, 10) !== tmpId) return // tv episode\r\n                } else {\r\n                    if (sub.IDMovieImdb && parseInt(sub.IDMovieImdb, 10) !== tmpId) return // movie\r\n                }\r\n            }\r\n\r\n            // episode check\r\n            if (input.season && input.episode && (sub.SeriesSeason !== parseInt(input.season).toString() || sub.SeriesEpisode !== parseInt(input.episode).toString())) return\r\n\r\n            const tmp = {\r\n                url: input.gzip ? sub.SubDownloadLink : sub.SubDownloadLink.replace('.gz', ''),\r\n                langcode: sub.ISO639,\r\n                downloads: sub.SubDownloadsCnt,\r\n                lang: sub.LanguageName,\r\n                encoding: sub.SubEncoding,\r\n                id: sub.IDSubtitleFile,\r\n                filename: sub.SubFileName,\r\n                score: 0\r\n            }\r\n\r\n\r\n            // score calculations\r\n            sub.MatchedBy === 'moviehash' && (tmp.score += 8)\r\n            sub.MatchedBy === 'tag' && (tmp.score += 7) || (tmp.score += matchTags(sub, 7))\r\n\r\n            let matchByFPS = sub.MovieFPS && input.fps && parseInt(sub.MovieFPS) > 0 && (sub.MovieFPS.startsWith(input.fps) || input.fps.toString().startsWith(sub.MovieFPS))\r\n            sub.MatchedBy === 'imdbid' && (tmp.score += 5) && matchByFPS && (tmp.score += 0.5)\r\n            !sub.MatchedBy.match(/moviehash|tag|imdbid/) && matchByFPS && (tmp.score += 2)\r\n\r\n            sub.UserRank.match(/trusted|administrator/) && (tmp.score += 4)\r\n            sub.UserRank.match(/platinum member|gold member/) && (tmp.score += 3)\r\n\r\n            // store subs for sorting\r\n            if (!subtitles[tmp.langcode]) {\r\n                subtitles[tmp.langcode] = [tmp]\r\n            } else {\r\n                subtitles[tmp.langcode][Object.keys(subtitles[tmp.langcode]).length] = tmp\r\n            }\r\n\r\n            return\r\n        })).then(() => subtitles)\r\n    }\r\n\r\n    filter(list = Object(), input) {\r\n        const subtitles = Object()\r\n\r\n        if (!input.limit || (isNaN(input.limit) && ['best', 'all'].indexOf(input.limit.toLowerCase()) == -1)) {\r\n            input.limit = 'best'\r\n        }\r\n\r\n        for (let i in list) {\r\n            let lang = list[i]\r\n            let langcode = lang[0].langcode\r\n\r\n            // sort by score, sub-sort by downloads\r\n            lang = lang.sort((a, b) => {\r\n                if (a.score === b.score) {\r\n                    let x = a.downloads\r\n                    let y = b.downloads\r\n                    return y < x ? -1 : y > x ? 1 : 0\r\n                }\r\n                return b.score - a.score\r\n            })\r\n\r\n            // filter\r\n            switch (input.limit.toString().toLowerCase()) {\r\n                case 'best':\r\n                    // keep only the first (best) item\r\n                    subtitles[langcode] = lang[0]\r\n                    break\r\n                case 'all':\r\n                    // all good already\r\n                    subtitles[langcode] = lang\r\n                    break\r\n                default:\r\n                    // keep only n = input.limit items\r\n                    subtitles[langcode] = lang.slice(0, parseInt(input.limit))\r\n            }\r\n        }\r\n\r\n        return Promise.resolve(subtitles)\r\n    }\r\n}","/home/travis/build/npmtest/node-npmtest-opensubtitles-api/node_modules/opensubtitles-api/lib/upload.js":"const libhash = require('./hash.js')\r\nconst path = require('path')\r\n\r\nmodule.exports = new class LibUpload {\r\n\r\n    // Create a valid object from passed info for TryUploadSubtitles\r\n    createTryData(input) {\r\n\r\n        const checkMovie = (obj = Object()) => {\r\n            if (!input.path) return Promise.resolve(obj)\r\n\r\n            return libhash.computeHash(input.path).then(response => {\r\n                obj = response // moviebytesize + moviehash\r\n                obj.moviefilename = path.basename(input.path)\r\n                return obj\r\n            })\r\n        }\r\n\r\n        const checkSub = (obj = Object()) => {\r\n            if (!input.subpath) return Promise.reject('Missing subpath parameter (path to subtitle file)')\r\n\r\n            return libhash.computeMD5(input.subpath).then(md5 => {\r\n                obj.subhash = md5\r\n                obj.subfilename = path.basename(input.subpath)\r\n                return obj\r\n            })\r\n        }\r\n\r\n        const injectInput = (obj = Object()) => {\r\n            if (input.imdbid) obj.idmovieimdb = input.imdbid.toString().replace('tt', '')\r\n            if (input.sublanguageid) obj.sublanguageid = input.sublanguageid\r\n            if (input.moviefps) obj.moviefps = input.moviefps.toString()\r\n            if (input.movieframes) obj.movieframes = input.movieframes.toString()\r\n            if (input.movietimems) obj.movietimems = input.movietimems.toString()\r\n            if (input.subauthorcomment) obj.subauthorcomment = input.subauthorcomment\r\n            if (input.subtranslator) obj.subtranslator = input.subtranslator\r\n            if (input.moviereleasename) obj.moviereleasename = input.moviereleasename\r\n            if (input.movieaka) obj.movieaka = input.movieaka\r\n            if (input.hearingimpaired) obj.hearingimpaired = isNaN(parseInt(input.hearingimpaired)) ? input.hearingimpaired ? '1' : '0' : input.hearingimpaired.toString()\r\n            if (input.highdefinition) obj.highdefinition = isNaN(parseInt(input.highdefinition)) ? input.highdefinition ? '1' : '0' : input.highdefinition.toString()\r\n            if (input.automatictranslation) obj.automatictranslation = isNaN(parseInt(input.automatictranslation)) ? input.automatictranslation ? '1' : '0' : input.automatictranslation.toString()\r\n            if (input.foreignpartsonly) obj.foreignpartsonly = isNaN(parseInt(input.foreignpartsonly)) ? input.foreignpartsonly ? '1' : '0' : input.foreignpartsonly.toString()\r\n\r\n            return obj\r\n        }\r\n\r\n        // mandatory: subhash (md5 of subtitles), subfilename, moviehash, moviebytesize, moviefilename\r\n        return checkMovie()\r\n            .then(checkSub)\r\n            .then(injectInput)\r\n            .then(data => ({cd1: data}))\r\n    }\r\n\r\n    // Create a valid object for Upload\r\n    arrangeUploadData(input) {\r\n        let baseinfo = Object()\r\n\r\n        if (input.idmovieimdb) baseinfo.idmovieimdb = input.idmovieimdb.toString()\r\n        if (input.sublanguageid) baseinfo.sublanguageid = input.sublanguageid\r\n        if (input.automatictranslation) baseinfo.automatictranslation = input.automatictranslation\r\n        if (input.subauthorcomment) baseinfo.subauthorcomment = input.subauthorcomment\r\n        if (input.subtranslator) baseinfo.subtranslator = input.subtranslator\r\n        if (input.highdefinition) baseinfo.highdefinition = input.highdefinition\r\n        if (input.releasename) baseinfo.moviereleasename = input.releasename\r\n        if (input.aka) baseinfo.movieaka = input.movieaka\r\n        if (input.hearingimpaired) baseinfo.hearingimpaired = input.hearingimpaired\r\n\r\n        let cd1 = {\r\n            subhash: input.subhash,\r\n            subfilename: input.subfilename,\r\n            subcontent: input.subcontent\r\n        }\r\n\r\n        if (input.moviebytesize) cd1.moviebytesize = input.moviebytesize.toString()\r\n        if (input.moviehash) cd1.moviehash = input.moviehash\r\n        if (input.moviefilename) cd1.moviefilename = input.moviefilename\r\n        if (input.moviefps) cd1.moviefps = input.moviefps\r\n        if (input.movieframes) cd1.movieframes = input.movieframes.toString()\r\n        if (input.movietimems) cd1.movietimems = input.movietimems.toString()\r\n\r\n        return {\r\n            baseinfo: baseinfo,\r\n            cd1: cd1\r\n        }\r\n    }\r\n\r\n    // Read subfile content\r\n    createContent(input) {\r\n        return libhash.computeSubContent(input.subpath).then(base64 => {\r\n            delete input.subpath\r\n            input.subcontent = base64\r\n            return input\r\n        })\r\n    }\r\n\r\n    // Analyze TryUploadSubtitles response and behave in function\r\n    parseResponse(response, input) {\r\n        if (response.data && response.data[0]) { // response\r\n            if (response.data[0].IDMovieImdb) { // response & response.imdb\r\n                input.idmovieimdb = response.data[0].IDMovieImdb\r\n                return input\r\n            } else { // response & no reponse.imdb\r\n                if (input.idmovieimdb) { // response & no response.imdb but input.imdb\r\n                    return input\r\n                } else { // response & no response.imdb & no input.imdb\r\n                    throw Error('Matching IMDB ID cannot be found')\r\n                }\r\n            }\r\n        } else { // no response\r\n            if (input.idmovieimdb) { // no response but input.imdb\r\n                return input\r\n            } else { // no response & no input.imdb\r\n                throw Error('Matching IMDB ID cannot be found')\r\n            }\r\n        }\r\n    }\r\n}","/home/travis/build/npmtest/node-npmtest-opensubtitles-api/node_modules/opensubtitles-api/lib/identify.js":"const libhash = require('./hash.js')\r\n\r\nconst path = require('path')\r\nconst fs = require('fs')\r\n\r\nmodule.exports = class LibID {\r\n    readNFO(file) {\r\n        let p = path.parse(file)\r\n        let nfo = path.join(p.dir, p.name + '.nfo')\r\n        let detectedId\r\n\r\n        if (!fs.existsSync(nfo)) {\r\n            for (let f of fs.readdirSync(p.dir)) {\r\n                if (f.match(/\\.nfo/i) !== null) {\r\n                    nfo = path.join(p.dir, f)\r\n                    break\r\n                }\r\n            }\r\n        }\r\n\r\n        detectedId = fs.readFileSync(nfo).toString().match(/tt\\d+/i)\r\n        return detectedId ? detectedId[0] : undefined\r\n    }\r\n\r\n\r\n    parseResponse(response, info) {\r\n        if (response.data === String() || !response.status.match(/200/)) throw new Error(response.status || 'OpenSubtitles unknown error')\r\n\r\n        let data = Object()\r\n\r\n        if (response.data[info.moviehash] && response.data[info.moviehash].length) { // we got valid info\r\n            data = {\r\n                subcount: response.data[info.moviehash].SubCount,\r\n                added: response.data.accepted_moviehashes ? true : false,\r\n                metadata: {\r\n                    imdbid: response.data[info.moviehash].MovieImdbID !== '0' ? 'tt' + response.data[info.moviehash].MovieImdbID : undefined,\r\n                    title: response.data[info.moviehash].MovieName,\r\n                    year: response.data[info.moviehash].MovieYear,\r\n                }\r\n            }\r\n            if (response.data[info.moviehash].SeriesEpisode + response.data[info.moviehash].SeriesSeason !== '00') {\r\n                data.metadata.episode = response.data[info.moviehash].SeriesEpisode\r\n                data.metadata.season = response.data[info.moviehash].SeriesSeason\r\n                data.metadata.episode_title = data.metadata.title.split('\"')[2].trim()\r\n                data.metadata.title = data.metadata.title.split('\"')[1].trim()\r\n            }\r\n\r\n        } else if (response.data.accepted_moviehashes && response.data.accepted_moviehashes.length) { // we pushed new hash\r\n            data.added = true\r\n        } else { // this was a waste of time\r\n            data.added = false\r\n        }\r\n\r\n        data.moviehash = info.moviehash // inject moviehash\r\n        data.moviebytesize = info.moviebytesize // inject moviebytesize\r\n\r\n        if (info.imdb && !data.metadata) { // inject imdb if possible\r\n            data.metadata = {\r\n                imdbid: 'tt' + info.imdb.replace('tt', '')\r\n            }\r\n        }\r\n\r\n        return data\r\n    }\r\n\r\n    extend(data, response) {\r\n        if (response.data !== String() && response.status.match(/200/)) {\r\n            if (response.data.kind.match(/episode/i)) {\r\n                data.type = 'episode'\r\n            } else if (response.data.kind.match(/movie/i)) {\r\n                data.type = 'movie'\r\n            } else {\r\n                delete data.metadata\r\n                return data // it is impossible that a single file is an entire show\r\n            }\r\n\r\n            data.metadata.cast = response.data.cast ? response.data.cast : Object()\r\n            data.metadata.country = response.data.country ? response.data.country : Array()\r\n            data.metadata.cover = response.data.cover\r\n            data.metadata.directors = response.data.directors ? response.data.directors : Object()\r\n            data.metadata.duration = response.data.duration\r\n            data.metadata.genres = response.data.genres ? response.data.genres : Array()\r\n            data.metadata.rating = response.data.rating\r\n            data.metadata.synopsis = response.data.plot && response.data.plot.match(/add a plot/i) !== null ? undefined : response.data.plot\r\n            data.metadata.year = response.data.year\r\n            data.metadata.trivia = response.data.trivia ? response.data.trivia.replace('See more >>', '').trim() : undefined\r\n            data.metadata.goofs = response.data.goofs\r\n            data.metadata.votes = response.data.votes\r\n            data.metadata.language = response.data.language ? response.data.language : Array()\r\n            data.metadata.aka = response.data.aka ? response.data.aka : Array()\r\n            data.metadata.awards = response.data.awards ? response.data.awards : Array()\r\n            data.metadata.tagline = response.data.tagline\r\n\r\n            if (data.type === 'episode' && response.data.episodeof) {\r\n                data.metadata.show_imdbid = Object.keys(response.data.episodeof).length > 0 ? Object.keys(response.data.episodeof)[0].replace('_','tt') : undefined\r\n            }\r\n        }\r\n\r\n        return data\r\n    }\r\n}"}